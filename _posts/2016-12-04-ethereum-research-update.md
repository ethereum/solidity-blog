---
id: 3514
title: Ethereum Research Update
date: 2016-12-04T11:27:47+00:00
author: Vitalik Buterin
layout: post
guid: https://blog.ethereum.org/?p=3514
permalink: /2016/12/04/ethereum-research-update/
---
This week marks the completion of our fourth hard fork, <a href="https://blog.ethereum.org/2016/11/18/hard-fork-no-4-spurious-dragon/">Spurious Dragon</a>, and the subsequent <a href="https://www.reddit.com/r/ethereum/comments/5es5g4/a_state_clearing_faq/">state clearing process</a>, the final steps in the two-hard-fork solution to the recent Ethereum <a href="https://blog.ethereum.org/2016/09/22/transaction-spam-attack-next-steps/">denial of service attacks</a> that slowed down the network in September and October. Gas limits are in the process of being increased to 4 million as the network returns to normal, and will be increased further as additional optimizations to clients are finished to allow quicker reading of state data.

In the midst of these events, we have seen great progress from the C++ and Go development teams, including <a href="https://www.reddit.com/r/ethereum/comments/5e5872/browsersolidity_now_features_some_static_analysis/">improvements to Solidity tools</a> and the release of the <a href="https://blog.ethereum.org/2016/11/17/whoa-geth-1-5/">Geth light client</a>, and the Parity, EthereumJ and other external development teams have continued pushing forward on their own with technologies such as Parity's <a href="https://github.com/ethcore/parity/wiki/Warp-Sync">warp sync</a>; many of these innovations have already made their way into the hands of the average user, and <a href="http://status.im">still others</a> are soon to come. At the same time, however, a large amount of quiet progress has been taking place on the research side, and while that progress has in many cases been rather blue-sky in nature and low-level protocol improvements necessarily take a while to make it into the main Ethereum network, we expect that the results of the work will start to bear fruit very soon.
<h3>Metropolis</h3>
Metropolis is the next major planned hardfork for Ethereum. While Metropolis is not quite as ambitious as Serenity and will not include proof of stake, sharding or any other similarly large sweeping changes to how Ethereum works, it is expected to include a series of small improvements to the protocol, which are altogether much more substantial than Homestead. Major improvements include:
<ul>
 	<li><a href="https://www.reddit.com/r/ethereum/comments/5ab69v/metropolis_protocol_change_proposal_highlight_for/">EIP 86 (account security abstraction)</a> - move the logic for verifying signatures and nonces into contracts, allowing developers to experiment with new signature schemes, privacy-preserving technologies and modifications to parts of the protocol without requiring further hard forks or support at the protocol level. Also allows contracts to pay for gas.</li>
 	<li><a href="https://github.com/ethereum/EIPs/issues/96">EIP 96 (blockhash and state root changes)</a> - simplifies the protocol and client implementations, and allows for upgrades to light client and fast-syncing protocols that make them much more secure.</li>
 	<li>Precompiled/native contracts for elliptic curve operations and big integer arithmetic, allowing for applications based on ring signatures or RSA cryptography to be implemented efficiently</li>
 	<li>Various improvements to efficiency that allow faster transaction processing</li>
</ul>
Much of this work is part of a long-term plan to move the protocol toward what we call <em>abstraction</em>. Essentially, instead of having complex protocol rules governing contract creation, transaction validation, mining and various other aspects of the system's behavior, we try to put as much of the Ethereum protocol's logic as possible into the EVM itself, and have protocol logic simply be a set of contracts. This reduces client complexity, reduces the long-run risk of consensus failures, and makes hard forks easier and safer - potentially, a hard fork could be specified simply as a config file that changes the code of a few contracts. By reducing the number of "moving parts" at the bottom level of the protocol in this way, we can greatly reduce Ethereum's attack surface, and open up more parts of the protocol to user experimentation: for example, instead of the protocol upgrading to a new signature scheme all at the same time, users are free to experiment and implement their own.
<h3>Proof of Stake, Sharding and Cryptoeconomics</h3>
Over the past year, research on proof of stake and sharding has been quietly moving forward. The consensus algorithm that we have been working on, Casper, has gone through several iterations and proof-of-concept releases, each of which taught us important things about the combination of economics and decentralized consensus. <a href="https://github.com/ethereum/pyethereum/tree/serenity">PoC release 2</a> came at the start of this year, although that approach has now been abandoned as it has become obvious that requiring every validator to send a message every block, or even every ten blocks, requires far too much overhead to be sustainable. The more traditional chain-based <a href="http://github.com/ethereum/pyethereum/tree/state_revamp">PoC3</a>, as described in the <a href="https://docs.google.com/document/d/1maFT3cpHvwn29gLvtY4WcQiI6kRbN_nbCf3JlgR3m_8/edit#">Mauve Paper</a>, has been more successful; although there are imperfections in how the incentives are structured, the flaws are much less serious in nature.

<img class="alignnone size-medium" src="http://www.initc3.org/images/events/btcp_wksp/1.jpg" alt="" width="2918" height="1370" />

Myself, Vlad and many volunteers from Ethereum research team came together at the <a href="http://www.cis.cornell.edu/ic3-and-ethereal-holding-cryptocurrency-boot-camp-cis">bootcamp at IC3</a> in July with university academics, Zcash developers and others to discuss proof of stake, sharding, privacy and other challenges, and substantial progress was made in bridging the gap between our approach to proof of stake and that of others who have been working on similar problems. A newer and simpler version of Casper began to solidify, and myself and Vlad continued on two separate paths: myself aiming to create a simple proof of stake protocol that would provide desirable properties with as few changes from proof of work as possible, and Vlad taking a "correct-by-construction" approach to rebuild consensus from the ground up. Both were presented at Devcon2 in Shanghai in September, and that's where we were at two weeks ago.

At the end of November, the research team (temporarily joined by Loi Luu, of <a href="https://eprint.iacr.org/2015/702.pdf">validator's dilemma</a> fame), along with some of our long-time volunteers and friends, came together for two weeks for a research workshop in Singapore, aiming to bring our thoughts together on various issues to do with Casper, scalability, consensus incentives and state size control.

<a href="https://blog.ethereum.org/wp-content/uploads/2016/12/IMG_20161201_151523.jpg"><img class="size-full wp-image-3532" src="https://blog.ethereum.org/wp-content/uploads/2016/12/IMG_20161201_151523.jpg" alt="dav" width="4608" height="3456" /></a>

A major topic of discussion was coming up with a rigorous and generalizable strategy for determining optimal incentives in consensus protocols - whether you're creating a chain-based protocol, a scalable sharding protocol, or even an incentivized version of PBFT, can we come up with a generalized way to correctly assign the right rewards and penalties to all participants, using only verifiable evidence that could be put into a blockchain as input, and in a way that would have optimal game-theoretic properties? We had some ideas; one of them, when applied to proof of work as an experiment, immediately led to a new path toward solving selfish mining attacks, and has also proven extremely promising in addressing long-standing issues in proof of stake.

A key goal of our approach to cryptoeconomics is ensuring as much incentive-compatibility as possible even under a model with majority collusions: even if an attacker controls 90% of the network, is there a way to make sure that, if the attacker deviates from the protocol in any harmful way, the attacker loses money? At least in some cases, such as short-range forks, the answer seems to be yes. In other cases, such as censorship, achieving this goal is much harder.

A second goal is bounding "griefing factors" - that is, ensuring that there is no way for an attacker to cause other players to lose money without losing close to the same amount of money themselves. A third goal is ensuring that the protocol continues to work as well as possible under other kinds of extreme conditions: for example, what if 60% of the validator nodes drop offline simultaneously? Traditional consensus protocols such as PBFT, and proof of stake protocols inspired by such approaches, simply halt in this case; our goal with Casper is for the chain to continue, and even if the chain can't provide all of the guarantees that it normally does under such conditions the protocol should still try to do as much as it can.

One of the main beneficial results of the workshop was bridging the gap between my current "exponential ramp-up" approach to transaction/block finality in Casper, which rewards validators for making bets with increasing confidence and penalizes them if their bets are wrong, and Vlad's "correct-by-construction" approach, which emphasizes penalizing validators only if they equivocate (ie. sign two incompatible messages). At the end of the workshop, we began to work together on strategies to combine the best of both approaches, and we have already started to use these insights to improve the Casper protocol.

In the meantime, I have written some documents and FAQs that detail the current state of thinking regarding proof of stake, sharding and Casper to help bring anyone interested up to speed:

<a href="https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ">https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ</a>

<a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQ">https://github.com/ethereum/wiki/wiki/Sharding-FAQ</a>

<a href="https://docs.google.com/document/d/1maFT3cpHvwn29gLvtY4WcQiI6kRbN_nbCf3JlgR3m_8">https://docs.google.com/document/d/1maFT3cpHvwn29gLvtY4WcQiI6kRbN_nbCf3JlgR3m_8</a> (Mauve Paper; now slightly out of date but will be updated soon)
<h3>State size control</h3>
Another important area of protocol design is state size control - that is, how to we reduce the amount of state information that full nodes need to keep track of? Right now, the state is about a gigabyte in size (the rest of the data that a geth or parity node currently stores is the transaction history; this data can theoretically be pruned once there is a robust light-client protocol for fetching it), and we saw already how protocol usability degrades in several ways if it grows much larger; additionally, sharding becomes much more difficult as sharded blockchains require nodes to be able to quickly download parts of the state as part of the process of serving as validators.

Some proposals that have been raised have to do with <a href="https://github.com/ethereum/EIPs/issues/168">deleting old non-contract accounts</a> with not enough ether to send a transaction, and doing so safely <a href="http://github.com/ethereum/EIPs/issues/169">so as to prevent replay attacks</a>. Other proposals involve simply making it much more expensive to create new accounts or store data, and doing so in a way that is more decoupled from the way that we pay for other kinds of costs inside the EVM. Still other proposals include putting time limits on how long contracts can last, and charging more to create accounts or contracts with longer time limits (the time limits here would be generous; it would still be affordable to create a contract that lasts several years). There is currently an ongoing debate in the developer community about the best way to achieve the goal of keeping state size small, while at the same time keeping the core protocol maximally user and developer-friendly.
<h3>Miscellanea</h3>
Other areas of low-level-protocol improvement on the horizon include:
<ul>
 	<li>Several <a href="https://github.com/ethereum/cpp-ethereum/issues/3404">"EVM 1.5" proposals</a> that make the EVM more friendly to static analysis, facilitating compatibility with WASM</li>
 	<li>Integration of zero knowledge proofs, likely through either (i) an explicit ZKP opcode/native contract, or (ii) an opcode or native contract for the key computationally intensive ingredients in ZKPs, particularly elliptic curve pairing computations</li>
 	<li>Further degrees of abstraction and protocol simplification</li>
</ul>
Expect more detailed documents and conversations on all of these topics in the months to come, especially as work on turning the Casper specification into a viable proof of concept release that could run a testnet continues to move forward.