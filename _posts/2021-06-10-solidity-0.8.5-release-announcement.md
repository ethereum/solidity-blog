---
layout: post
published: true
title: 'Solidity 0.8.5 Release Announcement'
date: '2021-06-10'
author: Solidity Team
category: Releases
---

[Solidity v0.8.5](https://github.com/ethereum/solidity/releases/tag/v0.8.5) allows byte conversion, adds ``verbatim``builtin function to inject arbitrary bytecode in Yul and fixes several smaller bugs.


## Notable New Features
### Bytes Conversion

This release introduces ability to convert `bytes` and `bytes` slices to fixed bytes types `bytes1`/../`bytes32`.
In case an array is longer than the target fixed type it will be truncated at the end:

```solidity
function f(bytes calldata c) public view returns (bytes8) {
	require(c.length == 16, "");
	bytes8 b = bytes8(c); // c is longer than 8 bytes, so truncation happens
	return b;
}
```

If the array is shorter than the target fixed type, it will be padded with zeros at the end:

```solidity
function f(bytes calldata c) public view returns (bytes8) {
	require(c.length == 30, "");
	bytes32 b = bytes32(c); // c is 30 bytes long, so b will be padded with two zero bytes at the end
	return b;
}
```

A nice example of using the `bytes` conversion feature would be its application in proxies:

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >0.8.4 <0.9.0;
contract Proxy {
	/// @dev Address of the client contract managed by proxy i.e., this contract
	address client;
	constructor(address _client) {
		client = _client;
	}
	/// Forward call to "setOwner(address)" that is implemented by client
	/// after doing basic validation on the address argument.
	function forward(bytes calldata _payload) external {
		// Since ABI decoding requires padded data, we cannot
		// use abi.decode(_payload[:4], (bytes4)).
		bytes4 sig =
			_payload[0] |
			(bytes4(_payload[1]) >> 8) |
			(bytes4(_payload[2]) >> 16) |
			(bytes4(_payload[3]) >> 24);
		bytes4 sig = bytes4(_payload[:4]);
		// Due to truncating behaviour, bytes4(_payload) performs identically.
		// bytes4 sig = bytes4(_payload);
		if (sig == bytes4(keccak256("setOwner(address)"))) {
			address owner = abi.decode(_payload[4:], (address));
			require(owner != address(0), "Address of owner cannot be zero.");
		}
		(bool status,) = client.delegatecall(_payload);
		require(status, "Forwarded call failed.");
	}
}
```

More details can be found in
the [documentation on explicit conversions](https://docs.soliditylang.org/en/v0.8.5/types.html#explicit-conversions)


### ``Verbatim``in Yul

This release introduces the set of `verbatim` builtin functions for Yul that allows you inject
arbitrary bytecode into the binary. This is currently only available via pure Yul, i.e., it is not
accessible via inline assembly.

The functions are `verbatim<n>i_<m>o("<data>", ...)`, where
- `n` is a decimal between 0 and 99 that specifies the number of input stack slots / variables,
- `m` is a decimal between 0 and 99 that specifies the number of output stack slots / variables,
- `data` is a string literal that contains the sequence of bytes.

As a practical example, one can use this to conveniently inject a newly proposed EVM opcode into the
binary. Take the proposed `BASEFEE` (at `0x48`) opcode (see [EIP-3198][1] and [EIP-1559][2]), since
the Solidity compiler currently does not support this opcode, one can use `verbatim` to implement it
in Yul.

```Yul
{
	function basefee() -> out {
		out := verbatim_0i_1o(hex"48")
	}

	sstore(0, basefee())
}
```

Here's another example that has an input parameter for `verbatim`.

```Yul
let x := calldataload(0)
// The hex"600202" corresponds to EVM instructions:
// PUSH 02 MUL
// That is, it multiplies x by 2.
let double := verbatim_1i_1o(hex"600202", x)
```

The above code will result in a `dup1` opcode to retrieve `x` (the optimizer may directly use the
result of the `calldataload` opcode, though) directly followed by `600202`. The code is assumed to
consume the (copied) value of `x` and produce the result on the top of the stack. The compiler then
generates code to allocate a stack slot for `double` and store the result there.

Note that there are some caveats when it comes to using `verbatim`. Details about it can be found in
the [documentation](https://docs.soliditylang.org/en/v0.8.5/yul.html#verbatim).


## Full Changelog

### Language Features:
 * Allowing conversion from ``bytes`` and ``bytes`` slices to ``bytes1``/.../``bytes32``.
 * Yul: Add ``verbatim`` builtin function to inject arbitrary bytecode.

### Compiler Features:
 * Code Generator: Insert helper functions for panic codes instead of inlining unconditionally. This can reduce costs if many panics (checks) are inserted, but can increase costs where few panics are used.
 * EVM: Set the default EVM version to "Berlin".
 * SMTChecker: Function definitions can be annotated with the custom Natspec tag ``custom:smtchecker abstract-function-nondet`` to be abstracted by a nondeterministic value when called.
 * Standard JSON / combined JSON: New artifact "functionDebugData" that contains bytecode offsets of entry points of functions and potentially more information in the future.
 * Yul Optimizer: Evaluate ``keccak256(a, c)``, when the value at memory location ``a`` is known at compile time and ``c`` is a constant ``<= 32``.

### Bugfixes:
 * AST: Do not output value of Yul literal if it is not a valid UTF-8 string.
 * Code Generator: Fix internal error when function arrays are assigned to storage variables and the function types can be implicitly converted but are not identical.
 * Code Generator: Fix internal error when super would have to skip an unimplemented function in the virtual resolution order.
 * Control Flow Graph: Assume unimplemented modifiers use a placeholder.
 * Control Flow Graph: Take internal calls to functions that always revert into account for reporting unused or unassigned variables.
 * Function Call Graph: Fix internal error connected with circular constant references.
 * Name Resolver: Do not issue shadowing warning if the shadowing name is not directly accessible.
 * Natspec: Allow multiple ``@return`` tags on public state variable documentation.
 * SMTChecker: Fix internal error on conversion from ``bytes`` to ``fixed bytes``.
 * SMTChecker: Fix internal error on external calls from the constructor.
 * SMTChecker: Fix internal error on struct constructor with fixed bytes member initialized with string literal.
 * Source Locations: Properly set source location of scoped blocks.
 * Standard JSON: Properly allow the ``inliner`` setting under ``settings.optimizer.details``.
 * Type Checker: Fix internal compiler error related to having mapping types in constructor parameter for abstract contracts.
 * Type Checker: Fix internal compiler error when attempting to use an invalid external function type on pre-byzantium EVMs.
 * Type Checker: Fix internal compiler error when overriding receive ether function with one having different parameters during inheritance.
 * Type Checker: Make errors about (nested) mapping type in event or error parameter into fatal type errors.

### AST Changes:
 * Add member `hexValue` for Yul string and hex literals.

A big thank you to all contributors who helped make this release possible!

Download the new version of Solidity [here](https://github.com/ethereum/solidity/releases/tag/v0.8.5).

[1]: https://eips.ethereum.org/EIPS/eip-3198
[2]: https://eips.ethereum.org/EIPS/eip-1559
